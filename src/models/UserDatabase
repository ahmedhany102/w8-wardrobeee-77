import bcrypt from 'bcryptjs';
import { v4 as uuidv4 } from 'uuid';

/**
 * @typedef {Object} User
 * @property {string} id
 * @property {string} name
 * @property {string} email
 * @property {string} password
 * @property {'ADMIN'|'USER'} role
 * @property {string} createdAt
 * @property {string} lastLogin
 * @property {string} ipAddress
 * @property {'ACTIVE'|'BLOCKED'|'PENDING'} status
 */

class UserDatabase {
  static instance;
  users = [];
  SALT_ROUNDS = 10;

  constructor() {
    if (UserDatabase.instance) return UserDatabase.instance;
    this.loadUsers();
    UserDatabase.instance = this;
  }

  static getInstance() {
    if (!UserDatabase.instance) {
      UserDatabase.instance = new UserDatabase();
    }
    return UserDatabase.instance;
  }

  loadUsers() {
    try {
      const storedUsers = localStorage.getItem('users');
      if (storedUsers) {
        this.users = JSON.parse(storedUsers);
      } else {
        this.createDefaultUsers();
      }
    } catch (error) {
      console.error('Error loading users:', error);
      this.createDefaultUsers();
    }
  }

  saveUsers() {
    try {
      localStorage.setItem('users', JSON.stringify(this.users));
    } catch (error) {
      console.error('Error saving users:', error);
    }
  }

  async hashPassword(password) {
    return bcrypt.hash(password, this.SALT_ROUNDS);
  }

  async verifyPassword(password, hash) {
    return bcrypt.compare(password, hash);
  }

  validatePassword(password) {
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return passwordRegex.test(password);
  }

  validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  createDefaultUsers() {
    const currentDate = new Date().toISOString();
    const defaultUsers = [
      {
        id: 'admin-1',
        name: 'Ahmed Hany',
        email: 'ahmedhanyseifeldien@gmail.com',
        password: 'Ahmedhany11*',
        role: 'ADMIN',
        createdAt: currentDate,
        lastLogin: currentDate,
        ipAddress: '192.168.1.1',
        status: 'ACTIVE'
      }
    ];
    Promise.all(defaultUsers.map(async (user) => {
      user.password = await this.hashPassword(user.password);
      return user;
    })).then((hashedUsers) => {
      this.users = hashedUsers;
      this.saveUsers();
    });
  }

  async registerUser(userData) {
    try {
      if (!this.validateEmail(userData.email)) {
        throw new Error('Invalid email format');
      }
      if (!this.validatePassword(userData.password)) {
        throw new Error('Password does not meet security requirements');
      }
      if (this.users.some(user => user.email === userData.email)) {
        throw new Error('Email already registered');
      }
      const hashedPassword = await this.hashPassword(userData.password);
      const newUser = {
        ...userData,
        id: uuidv4(),
        password: hashedPassword,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        ipAddress: '0.0.0.0',
        status: 'PENDING'
      };
      this.users.push(newUser);
      this.saveUsers();
      return true;
    } catch (error) {
      console.error('Error registering user:', error);
      return false;
    }
  }

  async loginUser(email, password) {
    try {
      const user = this.users.find(u => u.email === email);
      if (!user) return null;
      const isValid = await this.verifyPassword(password, user.password);
      if (!isValid) return null;
      user.lastLogin = new Date().toISOString();
      this.saveUsers();
      const { password: _, ...userWithoutPassword } = user;
      return userWithoutPassword;
    } catch (error) {
      console.error('Error during login:', error);
      return null;
    }
  }

  getAllUsers() {
    return this.users.map(({ password, ...user }) => user);
  }

  getUserById(id) {
    const user = this.users.find(u => u.id === id);
    if (!user) return null;
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  async updateUser(id, updates) {
    try {
      const userIndex = this.users.findIndex(u => u.id === id);
      if (userIndex === -1) return false;
      if (updates.email && !this.validateEmail(updates.email)) {
        throw new Error('Invalid email format');
      }
      if (updates.email && this.users.some(u => u.email === updates.email && u.id !== id)) {
        throw new Error('Email already in use');
      }
      this.users[userIndex] = {
        ...this.users[userIndex],
        ...updates
      };
      this.saveUsers();
      return true;
    } catch (error) {
      console.error('Error updating user:', error);
      return false;
    }
  }

  async updateUserRole(id, role) {
    return this.updateUser(id, { role });
  }

  async updateUserStatus(id, status) {
    return this.updateUser(id, { status });
  }

  async changePassword(id, currentPassword, newPassword) {
    try {
      const userIndex = this.users.findIndex(u => u.id === id);
      if (userIndex === -1) return false;
      const user = this.users[userIndex];
      const isValid = await this.verifyPassword(currentPassword, user.password);
      if (!isValid) return false;
      if (!this.validatePassword(newPassword)) {
        throw new Error('New password does not meet security requirements');
      }
      const hashedPassword = await this.hashPassword(newPassword);
      this.users[userIndex].password = hashedPassword;
      this.saveUsers();
      return true;
    } catch (error) {
      console.error('Error changing password:', error);
      return false;
    }
  }

  deleteUser(id) {
    try {
      const initialLength = this.users.length;
      this.users = this.users.filter(u => u.id !== id);
      if (this.users.length !== initialLength) {
        this.saveUsers();
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error deleting user:', error);
      return false;
    }
  }
}

export default UserDatabase; 
